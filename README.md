# Udacity-Algorithms
Udacity-Algorithms

-------

# Udacity

## 1. Intro_to_Algorithms
https://classroom.udacity.com/courses/cs215

## 2. Computability, Complexity & Algorithms
https://classroom.udacity.com/courses/ud061

## 3. Data Structures & Algorithms in Python
https://classroom.udacity.com/courses/ud513

## 4. Introduction to Graduate Algorithms
https://classroom.udacity.com/courses/ud401

## 5. High Performance Computing
https://classroom.udacity.com/courses/ud281

-------

# Papers

## 1. Data Structures and Algorithms Using Python
http://home.ustc.edu.cn/~huang83/ds/Data%20Structures%20and%20Algorithms%20Using%20Python.pdf

## 2. Introduction to High Performance Computing for Computational Scientists and Engineers
http://prdrklaina.weebly.com/uploads/5/7/7/3/5773421/introduction_to_high_performance_computing_for_scientists_and_engineers.pdf

## 3. Introduction to Algorithms: Third Edition
http://sd.blackball.lv/library/Introduction_to_Algorithms_Third_Edition_(2009).pdf

https://edutechlearners.com/download/Introduction_to_algorithms-3rd%20Edition.pdf



## 4. Data Structures and Algorithms in Python
http://index-of.es/Varios-2/Data%20Structures%20and%20Algorithms%20in%20Python.pdf

## 5. Kleinberg, Jon. Algorithm design / Jon Kleinberg, Éva Tardos
https://www.cs.sjtu.edu.cn/~jiangli/teaching/CS222/files/materials/Algorithm%20Design.pdf

https://github.com/grapestone5321/Udacity-Algorithms/blob/main/docs/Algorithm%20Design%20by%20Jon%20Kleinberg%2C%20Eva%20Tardos.pdf

-------

## Comparative Analysis of C++ and Python in Termsof Memory and Time



-------

## 1. Udacity-Intro_to_Algorithms
Udacity-Intro_to_Algorithms

https://classroom.udacity.com/courses/cs215

## Instructor: Michael Littman

Michael Lederman Littman (born August 30, 1966) is a computer scientist. 

He works mainly in reinforcement learning, but has done work in machine learning, game theory, computer networking, partially observable Markov decision process solving, computer solving of analogy problems and other areas. 

He is currently a professor of computer science at Brown University.


### LESSON 1: A Social Network Magic Trick

Become familiar with algorithm analysis.

Eulerian Path and Correctness of Na.

Russian peasants algorithm and more.

- Lesson 2: Problem set 1

### LESSON 3: Growth Rates in Social Networks

Use mathematical tools to analyze how things are connected.

Chain, ring and grid networks.

Big Theta and more.

- Lesson 4: Problem set 2

- Lesson 5: Problem set 2 solutions

### LESSON 6: Basic Graph Algorithms

Find the quickest route to Kevin Bacon.

Properties of social networks.

Clustering coefficient and more.

- Lesson 7: Problem set 3

- Lesson 8: Problem set 3 solutions



### LESSON 9: It's Who You Know

Learn to keep track of your best friends using heaps.

Degree centrality.

Top K Via Partitioning and more.

- Lesson 10: Problem set 4

- Lesson 11: Problem set 4 solutions


### LESSON 12: Strong and Weak Bonds

Work with social networks that have edge weights.

Make a tree and strength of connections.

Weighted social networks and more.

- Lesson 13: Problem set 5

### LESSON 14: Hardness of Network Problems

Explore what it means for a social network problem to be "harder" than other.

Tetristan and Exponential Running Time

Degrees of hardness and more.

- Lesson 15: Problem set 6

### LESSON ++: Review and Application

Interview with Peter Winker (Professor, Dartmouth College) on names and boxes problem and puzzles and algorithms.

Interview with Tina Eliassi-Rad (Professor, Rutgers University) on statistical measures in network and social networks in security and protests.

Additional interviews with Andrew Goldberg (Microsoft Research), Vukosi Marivate (Rutgers University) and Duncan Watts (Microsoft).

-------

## 2. Udacity-Computability, Complexity & Algorithms
https://classroom.udacity.com/courses/ud061

### LESSON 1
1. Languages & Countability

### LESSON 2
2. Turing Machines

### LESSON 3
3. Church-Turing Thesis

### LESSON 4
4. Universality

### LESSON 5
5. Undecidability

### LESSON 6
6. P and NP

### LESSON 7
7. NP - Completeness

### LESSON 8
8. NPC Problems

### LESSON 9
9. Dynamic Programming

### LESSON 10
10. FFT

### LESSON 11
11. Maximum Flow

### LESSON 12
12. BP Matching

### LESSON 13
13. Linear Programming

### LESSON 14
14. Duality

### LESSON 15
15. Approximation Algorithms

### LESSON 16
16. Randomized Algorithms

### LESSON 17
Assorted Exercises



-------

## 3. Data Structures & Algorithms in Python
https://classroom.udacity.com/courses/ud513


Below is the outline for this course—each section will include some mix of videos, text explanations, Python examples, and practice questions. 

The mix of formats will keep each bit of information interesting and digestible. 

Feel free to post in the forums if you have questions!

### 1. Introduction and Efficiency

- Course Introduction

- Syntax

- Efficiency

- Notation of Efficiency

### 2. List-Based Collections

- Lists/Arrays

- Linked Lists

- Stacks

- Queues

### 3. Searching and Sorting

- Binary Search

- Recursion

- Bubble Sort

- Merge Sort

- Quick Sort

### 4. Maps and Hashing

- Maps

- Hashing

- Collisions

- Hashing Conventions

- Trees

### 5. Trees

- Tree Traversal

- Binary Trees

- Binary Search Trees

- Heaps

- Self-Balancing Trees

### 6. Graphs

- Graphs

- Graph Properties

- Graph Representation

- Graph Traversal

- Graph Paths

### 7. Case Studies in Algorithms

- Shortest Path Problem

- Knapsack Problem

- Traveling Salesman Problem

### 8. Technical Interview Tips

- Mock Interview Breakdown

- Additional Tips

- Practice with Pramp

- Next Steps

-------


## 4. Introduction to Graduate Algorithms
https://classroom.udacity.com/courses/ud401

by Georgia Institute of Technology

Offered at Georgia Tech as CS 8803 GA

This is a graduate-level course in the design and analysis of algorithms. 

We study techniques for the design of algorithms (such as dynamic programming) and algorithms for fundamental problems (such as fast Fourier transform or FFT).

In addition, we study computational intractability, specifically, the theory of NP-completeness. 

The main topics covered in the course include: dynamic programming; divide and conquer, including FFT; randomized algorithms, including RSA cryptosystem and hashing using Bloom filters; graph algorithms; max-flow algorithms; linear programming; and NP-completeness.



### LESSON 1: Introduction to Graduate Algorithms
Overview of main topics covered, course webpage available at: https://gt-algorithms.com


### LESSON 2: DP1: FIB, LIS, LCS
Dynamic programming: Toy problem (Fibonacci numbers), Longest Increasing Subsequence (LIS), and Longest Common Subsequence (LCS).


### LESSON 3: DP2: Knapsack, Chain Multiply
Dynamic programming: Knapsack, and Chain Matrix Multiplication.

### LESSON 4: DP3: Shortest Paths
Dynamic programming algorithms for solving various shortest path problems on graphs.


### LESSON 5: RA1: Modular Arithmetic
Modular Arithmetic: Fast Modular Exponentiation and Multiplicative Inverses.


### LESSON 6: RA2: RSA
RSA Cryptosystem: Fermat's Little Theorem, RSA Protocol, and Primality Testing.


### LESSON 7: RA3: Bloom Filters
Lecture about Hashing: Toy problem of Balls into Bins, Traditional Chain Hashing, and Bloom Filters.


### LESSON 8: DC1: Fast Integer Multiplication
Faster Divide-and-Conquer Algorithm for Multiplying Large Integers.


### LESSON 9: DC2: Linear-Time Median
Linear-time Divide-and-Conquer Algorithm for Finding the Median from an unsorted list.


### LESSON 10: DC3: Solving Recurrences
Refresher Lecture about Solving Recurrences.


### LESSON 11: DC4: FFT - Part 1
High-level approach for polynomial multiplication and FFT (Fast Fourier Transform). Primer on complex numbers, including complex roots of unity.


### LESSON 12: DC5: FFT - Part 2
FFT and polynomial multiplication algorithms, and inverse FFT.


### LESSON 13: GR1: Strongly Connected Components
Connectivity: Connected components of undirected graphs, Topological sorting of a DAG, and strongly connected components of general directed graphs.


### LESSON 14: GR2: 2-Satisfiability
Polynomial-time algorithm for 2-SAT, using the SCC algorithm.


### LESSON 15: GR3: Minimum Spanning Tree
Minimum Spanning Tree (MST): Cut Property for MST's, and Kruskal's MST algorithm.


### LESSON 16: GR4: Markov Chains and PageRank
Introduction to Markov Chains, and an exposition of the PageRank algorithm.


### LESSON 17: MF1: Ford-Fulkerson Algorithm
Max-flow: Problem statement, residual network, and Ford-Fulkerson algorithm.


### LESSON 18: MF2: Max-Flow Min-Cut
Max-Flow Min-Cut Theorem: Statement and Proof, and proof of correctness of Ford-Fulkerson and Edmonds-Karp augmenting path algorithms.


### LESSON 19: MF3: Image Segmentation
Max-flow: Application to Image Segmentation problem.


### LESSON 20: MF4: Edmonds-Karp Algorithm
Max-flow: Edmonds-Karp augmenting path algorithm.


### LESSON 21: MF5: Max-Flow Generalization
Max-flow: Generalization allowing demand constraints.


### LESSON 22: LP1: Linear Programming
Linear Programming: Basics, Standard Form, and Simplex Algorithm Overview


### LESSON 23: LP2: Geometry
Geometry of Linear Programs: Feasible Region, Infeasible LP's, and Unbounded LP's.


### LESSON 24: LP3: Duality
Dual of a Linear Program; Converting an LP problem to its Dual; Weak and Strong Duality.


### LESSON 25: LP4: Max-SAT Approximation
Maximum Satisfiability Problem; Approximate Solutions; Integer Programming; Calculus.


### LESSON 26: NP1: Definitions
NP: Definition of a Search Problem and Computational Complexity Classes P and NP; Proving a Problem is in NP; Reductions; and the notion of NP-Completeness


### LESSON 27: NP2: 3SAT
3-SAT Problem is NP-Complete


### LESSON 28: NP3: Graph Problems
NP-Completeness of Graph Problems: Independent Sets, Clique, and Vertex Cover


### LESSON 29: NP4: Knapsack
Knapsack and Subset Sum Problems are NP-Complete


### LESSON 30: NP5: Halting Problem
Halting Problem is Undecidable



-------

## 5. High Performance Computing
https://classroom.udacity.com/courses/ud281


by Georgia Institute of Technology

Offered at Georgia Tech as CS 6220

The goal of this course is to give you solid foundations for developing, analyzing, and implementing parallel and locality-efficient algorithms. 

This course focuses on theoretical underpinnings. 

To give a practical feeling for how algorithms map to and behave on real systems, we will supplement algorithmic theory with hands-on exercises on modern HPC systems, such as Cilk Plus or OpenMP on shared memory nodes, CUDA for graphics co-processors (GPUs), and MPI and PGAS models for distributed memory systems.

This course is a graduate-level introduction to scalable parallel algorithms. 

"Scale" really refers to two things: efficient as the problem size grows, and efficient as the system size (measured in numbers of cores or compute nodes) grows. 

To really scale your algorithm in both of these senses, you need to be smart about reducing asymptotic complexity the way you’ve done for sequential algorithms since CS 101; but you also need to think about reducing communication and data movement. 

This course is about the basic algorithmic techniques you’ll need to do so.

The techniques you’ll encounter covers the main algorithm design and analysis ideas for three major classes of machines: for multicore and many core shared memory machines, via the work-span model; for distributed memory machines like clusters and supercomputers, via network models; and for sequential or parallel machines with deep memory hierarchies (e.g., caches). 

You will see these techniques applied to fundamental problems, like sorting, search on trees and graphs, and linear algebra, among others. 

The practical aspect of this course is implementing the algorithms and techniques you’ll learn to run on real parallel and distributed systems, so you can check whether what appears to work well in theory also translates into practice. 

(Programming models you’ll use include Cilk Plus, OpenMP, and MPI, and possibly others.)



### LESSON 1: Course Information

### LESSON 2: Introduction to High Performance Computing

### LESSON 3: Intro to the Work-Span Model

### LESSON 4: Intro to OpenMP

### LESSON 5: Comparison-based Sorting

### LESSON 6: Scans and List Ranking

### LESSON 7: Tree Computations

### LESSON 8: Shared Memory Parallel BFS

### LESSON 9: Sample Midterm

### LESSON 10: Intro to Dist. Memory Models

### LESSON 11: Intro to MPI

### LESSON 12: Topology

### LESSON 13: Dist. Dense Matrix Multiply

### LESSON 14: Dist. Memory Sorting

### LESSON 15: Distributed BFS

### LESSON 16: Graph Partitioning

### LESSON 17: Basic Model of Locality

### LESSON 18: Algorithmic Time, Energy and Power

### LESSON 19: I/O-Avoiding Algorithms

### LESSON 20: Cache-Oblivious Algorithms

### LESSON 21: Conclusion


-------

# Others

## 1. Data Structures and Algorithms Using Python
http://home.ustc.edu.cn/~huang83/ds/Data%20Structures%20and%20Algorithms%20Using%20Python.pdf

### Rance D. Necaise:
### Department of Computer Science College of William and Mary

Based on the authors’ market leading data structures books in Java and C++, this textbook offers a comprehensive, definitive introduction to data structures in Python by respected authors.  

Data Structures and Algorithms in Python is the first mainstream object-oriented book available for the Python data structures course.  

Designed to provide a comprehensive introduction to data structures and algorithms, including their design, analysis, and implementation, the text will maintain the same general structure as Data Structures and Algorithms in Java and Data Structures and Algorithms in C++.



### Chapter 1: Abstract Data Types 

      1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
      1.1.1 Abstractions . . . . . . . . . . . . . . . . . . . . . . . . . . 2
      1.1.2 Abstract Data Types . . . . . . . . . . . . . . . . . . . . . . 3
      1.1.3 Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . 5
      1.1.4 General Definitions . . . . . . . . . . . . . . . . . . . . . . . 6
      1.2 The Date Abstract Data Type . . . . . . . . . . . . . . . . . . . . . 7
      1.2.1 Defining the ADT . . . . . . . . . . . . . . . . . . . . . . . . 7
      1.2.2 Using the ADT . . . . . . . . . . . . . . . . . . . . . . . . . 8
      1.2.3 Preconditions and Postconditions . . . . . . . . . . . . . . . 9
      1.2.4 Implementing the ADT . . . . . . . . . . . . . . . . . . . . . 10
      1.3 Bags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
      1.3.1 The Bag Abstract Data Type . . . . . . . . . . . . . . . . . 15
      1.3.2 Selecting a Data Structure . . . . . . . . . . . . . . . . . . 17
      1.3.3 List-Based Implementation . . . . . . . . . . . . . . . . . . 19
      1.4 Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
      1.4.1 Designing an Iterator . . . . . . . . . . . . . . . . . . . . . 21
      1.4.2 Using Iterators . . . . . . . . . . . . . . . . . . . . . . . . . 22
      1.5 Application: Student Records . . . . . . . . . . . . . . . . . . . . . 23
      1.5.1 Designing a Solution . . . . . . . . . . . . . . . . . . . . . . 23
      1.5.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 26
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
      
### Chapter 2: Arrays 

      2.1 The Array Structure . . . . . . . . . . . . . . . . . . . . . . . . . . 33
      2.1.1 Why Study Arrays? . . . . . . . . . . . . . . . . . . . . . . . 34
      2.1.2 The Array Abstract Data Type . . . . . . . . . . . . . . . . . 34
      2.1.3 Implementing the Array . . . . . . . . . . . . . . . . . . . . 36
      2.2 The Python List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
      2.2.1 Creating a Python List . . . . . . . . . . . . . . . . . . . . . 41
      2.2.2 Appending Items . . . . . . . . . . . . . . . . . . . . . . . . 42
      2.2.3 Extending A List . . . . . . . . . . . . . . . . . . . . . . . . 44
      2.2.4 Inserting Items . . . . . . . . . . . . . . . . . . . . . . . . . 44
      2.2.5 List Slice . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
      2.3 Two-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . 47
      2.3.1 The Array2D Abstract Data Type . . . . . . . . . . . . . . . 47
      2.3.2 Implementing the 2-D Array . . . . . . . . . . . . . . . . . . 49
      2.4 The Matrix Abstract Data Type . . . . . . . . . . . . . . . . . . . . 52
      2.4.1 Matrix Operations . . . . . . . . . . . . . . . . . . . . . . . 53
      2.4.2 Implementing the Matrix . . . . . . . . . . . . . . . . . . . . 55
      2.5 Application: The Game of Life . . . . . . . . . . . . . . . . . . . . . 57
      2.5.1 Rules of the Game . . . . . . . . . . . . . . . . . . . . . . . 57
      2.5.2 Designing a Solution . . . . . . . . . . . . . . . . . . . . . . 59
      2.5.3 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 61
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
      
### Chapter 3: Sets and Maps 

      3.1 Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
      3.1.1 The Set Abstract Data Type . . . . . . . . . . . . . . . . . . 70
      3.1.2 Selecting a Data Structure . . . . . . . . . . . . . . . . . . 72
      3.1.3 List-Based Implementation . . . . . . . . . . . . . . . . . . 72
      3.2 Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
      3.2.1 The Map Abstract Data Type . . . . . . . . . . . . . . . . . 76
      3.2.2 List-Based Implementation . . . . . . . . . . . . . . . . . . 77
      3.3 Multi-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . 80
      3.3.1 The MultiArray Abstract Data Type . . . . . . . . . . . . . . 81
      3.3.2 Data Organization . . . . . . . . . . . . . . . . . . . . . . . 81
      3.3.3 Variable-Length Arguments . . . . . . . . . . . . . . . . . . 85
      3.3.4 Implementing the MultiArray . . . . . . . . . . . . . . . . . . 86
      3.4 Application: Sales Reports . . . . . . . . . . . . . . . . . . . . . . 89
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
      
### Chapter 4: Algorithm Analysis 

      4.1 Complexity Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . 97
      4.1.1 Big-O Notation . . . . . . . . . . . . . . . . . . . . . . . . . 99
      4.1.2 Evaluating Python Code . . . . . . . . . . . . . . . . . . . . 104
      4.2 Evaluating the Python List . . . . . . . . . . . . . . . . . . . . . . . 108
      4.3 Amortized Cost . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
      4.4 Evaluating the Set ADT . . . . . . . . . . . . . . . . . . . . . . . . 113
      4.5 Application: The Sparse Matrix . . . . . . . . . . . . . . . . . . . . 115
      4.5.1 List-Based Implementation . . . . . . . . . . . . . . . . . . 115
      4.5.2 Efficiency Analysis . . . . . . . . . . . . . . . . . . . . . . . 120
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
      
### Chapter 5: Searching and Sorting 

      5.1 Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
      5.1.1 The Linear Search . . . . . . . . . . . . . . . . . . . . . . . 126
      5.1.2 The Binary Search . . . . . . . . . . . . . . . . . . . . . . . 128
      5.2 Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
      5.2.1 Bubble Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
      5.2.2 Selection Sort . . . . . . . . . . . . . . . . . . . . . . . . . 136
      5.2.3 Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . 138
      5.3 Working with Sorted Lists . . . . . . . . . . . . . . . . . . . . . . . 142
      5.3.1 Maintaining a Sorted List . . . . . . . . . . . . . . . . . . . 142
      5.3.2 Merging Sorted Lists . . . . . . . . . . . . . . . . . . . . . . 143
      5.4 The Set ADT Revisited . . . . . . . . . . . . . . . . . . . . . . . . . 147
      5.4.1 A Sorted List Implementation . . . . . . . . . . . . . . . . . 147
      5.4.2 Comparing the Implementations . . . . . . . . . . . . . . . 152
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
      
### Chapter 6: Linked Structures 

      6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
      6.2 The Singly Linked List . . . . . . . . . . . . . . . . . . . . . . . . . 159
      6.2.1 Traversing the Nodes . . . . . . . . . . . . . . . . . . . . . 159
      6.2.2 Searching for a Node . . . . . . . . . . . . . . . . . . . . . 161
      6.2.3 Prepending Nodes . . . . . . . . . . . . . . . . . . . . . . . 162
      6.2.4 Removing Nodes . . . . . . . . . . . . . . . . . . . . . . . . 163
      6.3 The Bag ADT Revisited . . . . . . . . . . . . . . . . . . . . . . . . 165
      6.3.1 A Linked List Implementation . . . . . . . . . . . . . . . . . 165
      6.3.2 Comparing Implementations . . . . . . . . . . . . . . . . . 167
      6.3.3 Linked List Iterators . . . . . . . . . . . . . . . . . . . . . . 168
      6.4 More Ways to Build a Linked List . . . . . . . . . . . . . . . . . . . 169
      6.4.1 Using a Tail Reference . . . . . . . . . . . . . . . . . . . . . 169
      6.4.2 The Sorted Linked List . . . . . . . . . . . . . . . . . . . . . 171
      6.5 The Sparse Matrix Revisited . . . . . . . . . . . . . . . . . . . . . 174
      6.5.1 An Array of Linked Lists Implementation . . . . . . . . . . . 175
      6.5.2 Comparing the Implementations . . . . . . . . . . . . . . . 178
      6.6 Application: Polynomials . . . . . . . . . . . . . . . . . . . . . . . . 179
      6.6.1 Polynomial Operations . . . . . . . . . . . . . . . . . . . . . 179
      6.6.2 The Polynomial ADT . . . . . . . . . . . . . . . . . . . . . . 181
      6.6.3 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 181
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
      
### Chapter 7: Stacks 

      7.1 The Stack ADT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
      7.2 Implementing the Stack . . . . . . . . . . . . . . . . . . . . . . . . 195
      7.2.1 Using a Python List . . . . . . . . . . . . . . . . . . . . . . 195
      7.2.2 Using a Linked List . . . . . . . . . . . . . . . . . . . . . . . 196
      7.3 Stack Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
      7.3.1 Balanced Delimiters . . . . . . . . . . . . . . . . . . . . . . 199
      7.3.2 Evaluating Postfix Expressions . . . . . . . . . . . . . . . . 202
      7.4 Application: Solving a Maze . . . . . . . . . . . . . . . . . . . . . . 206
      7.4.1 Backtracking . . . . . . . . . . . . . . . . . . . . . . . . . . 207
      7.4.2 Designing a Solution . . . . . . . . . . . . . . . . . . . . . . 208
      7.4.3 The Maze ADT . . . . . . . . . . . . . . . . . . . . . . . . . 211
      7.4.4 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 214
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
      
### Chapter 8: Queues 

      8.1 The Queue ADT . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
      8.2 Implementing the Queue . . . . . . . . . . . . . . . . . . . . . . . . 222
      8.2.1 Using a Python List . . . . . . . . . . . . . . . . . . . . . . 222
      8.2.2 Using a Circular Array . . . . . . . . . . . . . . . . . . . . . 224
      8.2.3 Using a Linked List . . . . . . . . . . . . . . . . . . . . . . . 228
      8.3 Priority Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
      8.3.1 The Priority Queue ADT . . . . . . . . . . . . . . . . . . . . 230
      8.3.2 Implementation: Unbounded Priority Queue . . . . . . . . . 232
      8.3.3 Implementation: Bounded Priority Queue . . . . . . . . . . 235
      8.4 Application: Computer Simulations . . . . . . . . . . . . . . . . . . 237
      8.4.1 Airline Ticket Counter . . . . . . . . . . . . . . . . . . . . . 237
      8.4.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 239
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
      
### Chapter 9: Advanced Linked Lists 

      9.1 The Doubly Linked List . . . . . . . . . . . . . . . . . . . . . . . . . 247
      9.1.1 Organization . . . . . . . . . . . . . . . . . . . . . . . . . . 247
      9.1.2 List Operations . . . . . . . . . . . . . . . . . . . . . . . . . 248
      9.2 The Circular Linked List . . . . . . . . . . . . . . . . . . . . . . . . 253
      9.2.1 Organization . . . . . . . . . . . . . . . . . . . . . . . . . . 253
      9.2.2 List Operations . . . . . . . . . . . . . . . . . . . . . . . . . 254
      9.3 Multi-Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
      9.3.1 Multiple Chains . . . . . . . . . . . . . . . . . . . . . . . . . 259
      9.3.2 The Sparse Matrix . . . . . . . . . . . . . . . . . . . . . . . 260
      9.4 Complex Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
      9.5 Application: Text Editor . . . . . . . . . . . . . . . . . . . . . . . . . 263
      9.5.1 Typical Editor Operations . . . . . . . . . . . . . . . . . . . 263
      9.5.2 The Edit Buffer ADT . . . . . . . . . . . . . . . . . . . . . . 266
      9.5.3 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 268
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
      
### Chapter 10: Recursion 

      10.1 Recursive Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 277
      10.2 Properties of Recursion . . . . . . . . . . . . . . . . . . . . . . . . 279
      10.2.1 Factorials . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
      10.2.2 Recursive Call Trees . . . . . . . . . . . . . . . . . . . . . . 281
      10.2.3 The Fibonacci Sequence . . . . . . . . . . . . . . . . . . . 283
      10.3 How Recursion Works . . . . . . . . . . . . . . . . . . . . . . . . . 283
      10.3.1 The Run Time Stack . . . . . . . . . . . . . . . . . . . . . . 284
      10.3.2 Using a Software Stack . . . . . . . . . . . . . . . . . . . . 286
      10.3.3 Tail Recursion . . . . . . . . . . . . . . . . . . . . . . . . . 289
      10.4 Recursive Applications . . . . . . . . . . . . . . . . . . . . . . . . . 290
      10.4.1 Recursive Binary Search . . . . . . . . . . . . . . . . . . . 290
      10.4.2 Towers of Hanoi . . . . . . . . . . . . . . . . . . . . . . . . 292
      10.4.3 Exponential Operation . . . . . . . . . . . . . . . . . . . . . 296
      10.4.4 Playing Tic-Tac-Toe . . . . . . . . . . . . . . . . . . . . . . 297
      10.5 Application: The Eight-Queens Problem . . . . . . . . . . . . . . . 299
      10.5.1 Solving for Four-Queens . . . . . . . . . . . . . . . . . . . . 301
      10.5.2 Designing a Solution . . . . . . . . . . . . . . . . . . . . . . 303
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
      
### Chapter 11: Hash Tables 

      11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
      11.2 Hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
      11.2.1 Linear Probing . . . . . . . . . . . . . . . . . . . . . . . . . 312
      11.2.2 Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
      11.2.3 Rehashing . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
      11.2.4 Efficiency Analysis . . . . . . . . . . . . . . . . . . . . . . . 320
      11.3 Separate Chaining . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
      11.4 Hash Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
      11.5 The HashMap Abstract Data Type . . . . . . . . . . . . . . . . . . 325
      11.6 Application: Histograms . . . . . . . . . . . . . . . . . . . . . . . . 330
      11.6.1 The Histogram Abstract Data Type . . . . . . . . . . . . . . 330
      11.6.2 The Color Histogram . . . . . . . . . . . . . . . . . . . . . . 334
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
      
### Chapter 12: Advanced Sorting 

      12.1 Merge Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
      12.1.1 Algorithm Description . . . . . . . . . . . . . . . . . . . . . 340
      12.1.2 Basic Implementation . . . . . . . . . . . . . . . . . . . . . 340
      12.1.3 Improved Implementation . . . . . . . . . . . . . . . . . . . 342
      12.1.4 Efficiency Analysis . . . . . . . . . . . . . . . . . . . . . . . 345
      12.2 Quick Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
      12.2.1 Algorithm Description . . . . . . . . . . . . . . . . . . . . . 348
      12.2.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 349
      12.2.3 Efficiency Analysis . . . . . . . . . . . . . . . . . . . . . . . 353
      12.3 How Fast Can We Sort? . . . . . . . . . . . . . . . . . . . . . . . . 353
      12.4 Radix Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354
      12.4.1 Algorithm Description . . . . . . . . . . . . . . . . . . . . . 354
      12.4.2 Basic Implementation . . . . . . . . . . . . . . . . . . . . . 356
      12.4.3 Efficiency Analysis . . . . . . . . . . . . . . . . . . . . . . . 358
      12.5 Sorting Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . . . 358
      12.5.1 Insertion Sort . . . . . . . . . . . . . . . . . . . . . . . . . . 359
      12.5.2 Merge Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
      
### Chapter 13: Binary Trees 

      13.1 The Tree Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
      13.2 The Binary Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
      13.2.1 Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
      13.2.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 375
      13.2.3 Tree Traversals . . . . . . . . . . . . . . . . . . . . . . . . . 376
      13.3 Expression Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
      13.3.1 Expression Tree Abstract Data Type . . . . . . . . . . . . . 382
      13.3.2 String Representation . . . . . . . . . . . . . . . . . . . . . 383
      13.3.3 Tree Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . 384
      13.3.4 Tree Construction . . . . . . . . . . . . . . . . . . . . . . . 386
      13.4 Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390
      13.4.1 Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391
      13.4.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 395
      13.4.3 The Priority Queue Revisited . . . . . . . . . . . . . . . . . 398
      13.5 Heapsort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 400
      13.5.1 Simple Implementation . . . . . . . . . . . . . . . . . . . . 400
      13.5.2 Sorting In Place . . . . . . . . . . . . . . . . . . . . . . . . 400
      13.6 Application: Morse Code . . . . . . . . . . . . . . . . . . . . . . . . 404
      13.6.1 Decision Trees . . . . . . . . . . . . . . . . . . . . . . . . . 405
      13.6.2 The ADT Definition . . . . . . . . . . . . . . . . . . . . . . . 406
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
      
### Chapter 14: Search Trees 

      14.1 The Binary Search Tree . . . . . . . . . . . . . . . . . . . . . . . . 412
      14.1.1 Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
      14.1.2 Min and Max Values . . . . . . . . . . . . . . . . . . . . . . 415
      14.1.3 Insertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
      14.1.4 Deletions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
      14.1.5 Efficiency of Binary Search Trees . . . . . . . . . . . . . . . 425
      14.2 Search Tree Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . 427
      14.3 AVL Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
      14.3.1 Insertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430
      14.3.2 Deletions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
      14.3.3 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 435
      14.4 The 2-3 Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
      14.4.1 Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
      14.4.2 Insertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
      14.4.3 Efficiency of the 2-3 Tree . . . . . . . . . . . . . . . . . . . 449
      Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
      Programming Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
      
### Appendix A: Python Review 

      A.1 The Python Interpreter . . . . . . . . . . . . . . . . . . . . . . . . . 453
      A.2 The Basics of Python . . . . . . . . . . . . . . . . . . . . . . . . . 454
      A.2.1 Primitive Types . . . . . . . . . . . . . . . . . . . . . . . . . 455
      A.2.2 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . 456
      A.2.3 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
      A.2.4 Arithmetic Operators . . . . . . . . . . . . . . . . . . . . . . 458
      A.2.5 Logical Expressions . . . . . . . . . . . . . . . . . . . . . . 459
      A.2.6 Using Functions and Methods . . . . . . . . . . . . . . . . 461
      A.2.7 Standard Library . . . . . . . . . . . . . . . . . . . . . . . . 462
      A.3 User Interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
      A.3.1 Standard Input . . . . . . . . . . . . . . . . . . . . . . . . . 463
      A.3.2 Standard Output . . . . . . . . . . . . . . . . . . . . . . . . 464
      A.4 Control Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
      A.4.1 Selection Constructs . . . . . . . . . . . . . . . . . . . . . . 467
      A.4.2 Repetition Constructs . . . . . . . . . . . . . . . . . . . . . 469
      A.5 Collections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
      A.5.1 Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
      A.5.2 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 473
      A.5.3 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 475
      A.5.4 Dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . 475
      A.6 Text Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
      A.6.1 File Access . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
      A.6.2 Writing to Files . . . . . . . . . . . . . . . . . . . . . . . . . 478
      A.6.3 Reading from Files . . . . . . . . . . . . . . . . . . . . . . . 479
      A.7 User-Defined Functions . . . . . . . . . . . . . . . . . . . . . . . . 480
      A.7.1 The Function Definition . . . . . . . . . . . . . . . . . . . . 480
      A.7.2 Variable Scope . . . . . . . . . . . . . . . . . . . . . . . . . 483
      A.7.3 Main Routine . . . . . . . . . . . . . . . . . . . . . . . . . . 483
      
### Appendix B: User-Defined Modules 

      B.1 Structured Programs . . . . . . . . . . . . . . . . . . . . . . . . . . 485
      B.2 Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 486
      
### Appendix C: Exceptions 

      C.1 Catching Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . 489
      C.2 Raising Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
      C.3 Standard Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . 491
      C.4 Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
      
### Appendix D: Classes 

      D.1 The Class Definition . . . . . . . . . . . . . . . . . . . . . . . . . . 493
      D.1.1 Constructors . . . . . . . . . . . . . . . . . . . . . . . . . . 494
      D.1.2 Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 495
      D.1.3 Using Modules . . . . . . . . . . . . . . . . . . . . . . . . . 497
      D.1.4 Hiding Attributes . . . . . . . . . . . . . . . . . . . . . . . . 498
      D.2 Overloading Operators . . . . . . . . . . . . . . . . . . . . . . . . . 500
      D.3 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
      D.3.1 Deriving Child Classes . . . . . . . . . . . . . . . . . . . . . 503
      D.3.2 Creating Class Instances . . . . . . . . . . . . . . . . . . . 504
      D.3.3 Invoking Methods . . . . . . . . . . . . . . . . . . . . . . . 505
      D.4 Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507

-------

## 2. Introduction to High Performance Computing for Computational Scientists and Engineers
by Georg Hager and Gerhard Wellein.

ISBN: 978-1-4398-1192-4, CRC Press, 2010.

http://prdrklaina.weebly.com/uploads/5/7/7/3/5773421/introduction_to_high_performance_computing_for_scientists_and_engineers.pdf

-------

## 3. Introduction to Algorithms
Third Edition

http://sd.blackball.lv/library/Introduction_to_Algorithms_Third_Edition_(2009).pdf



-------

## 4. Data Structures and Algorithms in Python
http://index-of.es/Varios-2/Data%20Structures%20and%20Algorithms%20in%20Python.pdf


### Michael T. Goodrich
Department of Computer Science

University of California, Irvine

### Roberto Tamassia
Department of Computer Science

Brown University

### Michael H. Goldwasser
Department of Mathematics and Computer Science

Saint Louis University

-------



